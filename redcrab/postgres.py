import psycopg2

from redcrab.postgres_schema import DATABASE


def build_database(host, user, password):
    """
    Set up the database user, the tablespace and set all grants
    """
    # Create the database
    db_connection = psycopg2.connect(host=host, user=user, password=password, database="postgres")
    with db_connection.cursor() as cursor:
        db_connection.set_isolation_level(psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)
        cursor.execute("CREATE USER {}".format(DATABASE["owner"]))
        cursor.execute("CREATE DATABASE {};".format(DATABASE["name"], DATABASE["owner"]))
    db_connection.close()

    db_connection = psycopg2.connect(host=host, user=DATABASE["owner"], database=DATABASE["name"])  # no password for now
    with db_connection.cursor() as cursor:
        for table, vals in DATABASE["tables"].iteritems():
            tablesql = "create table {} ({}".format(
                table,
                ",".join(["{} {}".format(name, type_) for name, type_ in vals["rows"].iteritems()])
            )
            if vals.get("pk"):
                tablesql = "{},primary key ({})".format(tablesql, vals["pk"])
            if vals.get("fk"):
                tablesql = "{},foreign key ({}) references {} ({})".format(
                    tablesql,
                    vals["fk"]["child_key"],
                    vals["fk"]["parent_table"],
                    vals["fk"]["parent_key"]
                )
            tablesql = "{});".format(tablesql)
            cursor.execute(tablesql)
            # GRANT ALL because why not right?
            cursor.execute("GRANT ALL ON {} TO {};".format(table, DATABASE["owner"]))
    db_connection.commit()
    db_connection.close()


def create_connection(host, db, user, password):
    db_connection = psycopg2.connect(host=host, database=db, user=user, password=password)
    # Create all prepared statements. For now keep a fairly minimal schema. Schema will likely
    # be the thing that I need to change most frequently in the future but for now I just want
    # something functional that suits my purposes
    with db_connection.cursor() as cursor:
        cursor.execute(
            "PREPARE comment_insert (text, char, char) AS INSERT INTO comments VALUES ($1, $2, $3);"
        )
        cursor.execute(
            "PREPARE submission_insert (text, char) AS INSERT INTO submissions VALUES ($1, $2);"
        )
    return db_connection


def store_comment(comment, submission, db_connection):
    """
    Takes a comment object and stores it in the database
    """
    body = comment.body.replace("'", "''")
    with db_connection.cursor() as cursor:
        try:
            cursor.execute(
                u"EXECUTE comment_insert('{}', '{}', '{}');".format(body, comment.id, submission.id)
            )
        # The big thing that I always see is that duplicates of the same comment make it into
        # any tree of comments generated by praw. The problem might actually reside in the reddit
        # API but either way we should just catch any IntegrityErrors coming from duplication of
        # primary keys and just rollback
        except psycopg2.IntegrityError:
            db_connection.rollback()
        else:
            db_connection.commit()


def store_submission(submission, db_connection):
    """
    Takes a submission object and stores it in the database
    """
    title = submission.title.replace("'", "''")
    with db_connection.cursor() as cursor:
        try:
            cursor.execute(u"EXECUTE submission_insert('{}', '{}');".format(title, submission.id))
        except psycopg2.IntegrityError as err:
            db_connection.rollback()
            raise err
        else:
            db_connection.commit()
